<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Lights Photo App</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #2a4365;
        }
        
        .tab-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #cbd5e0;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            margin: 0 5px;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            border-bottom: 2px solid #4299e1;
            font-weight: bold;
            color: #2b6cb0;
        }
        
        .editor-container {
            display: flex;
            align-items: stretch;
            margin-bottom: 20px;
        }
        
        .control-sidebar {
            width: 60px;
            margin-right: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        
        .density-slider-container {
            height: 200px;
            width: 40px;
            background-color: #e2e8f0;
            border-radius: 8px;
            position: relative;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 0;
        }
        
        .density-slider {
            width: 100%;
            height: 100%;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
            writing-mode: bt-lr; /* Orient vertically */
            -webkit-appearance: slider-vertical;
            /* Remove the transform to fix the orientation */
        }
        
        .density-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }
        
        .density-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }
        
        .density-label {
            font-size: 10px;
            margin-top: 5px;
            color: #4a5568;
            text-align: center;
        }
        
        .slider-tick {
            position: absolute;
            width: 100%;
            left: 0;
            height: 1px;
            background-color: #a0aec0;
        }
        
        .slider-tick.min {
            bottom: 10px;
        }
        
        .slider-tick.mid {
            bottom: 50%;
        }
        
        .slider-tick.max {
            top: 10px;
        }
        
        .slider-value {
            position: absolute;
            right: -25px;
            font-size: 10px;
            color: #4a5568;
        }
        
        .color-bar-container {
            height: 200px;
            width: 40px;
            background: #f0f0f0; /* Neutral background instead of predefined gradient */
            border-radius: 8px;
            position: relative;
            overflow: visible;
        }
        
        .color-marker {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid white;
            right: -10px;
            transform: translateY(-50%);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .color-marker:hover::after {
            content: "Ã—";
            position: absolute;
            top: -12px;
            right: -12px;
            width: 16px;
            height: 16px;
            background-color: #ef4444;
            color: white;
            border-radius: 50%;
            font-size: 12px;
            line-height: 16px;
            text-align: center;
            font-weight: bold;
            opacity: 0.9;
        }
        
        .input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a202c;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            aspect-ratio: 16/9;
            flex-grow: 1;
        }
        
        .input-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        video, img, canvas {
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
        }
        
        .button-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        
        .button {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }
        
        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .button-blue {
            background-color: #3b82f6;
        }
        
        .button-blue:hover:not(:disabled) {
            background-color: #2563eb;
        }
        
        .button-green {
            background-color: #10b981;
        }
        
        .button-green:hover:not(:disabled) {
            background-color: #059669;
        }
        
        .button-purple {
            background-color: #8b5cf6;
        }
        
        .button-purple:hover:not(:disabled) {
            background-color: #7c3aed;
        }
        
        .button-red {
            background-color: #ef4444;
        }
        
        .button-red:hover:not(:disabled) {
            background-color: #dc2626;
        }
        
        .button-gray {
            background-color: #6b7280;
        }
        
        .button-gray:hover:not(:disabled) {
            background-color: #4b5563;
        }
        
        .file-input {
            position: absolute;
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            z-index: -1;
        }
        
        .file-label {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 6px;
            background-color: #3b82f6;
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }
        
        .file-label:hover {
            background-color: #2563eb;
        }
        
        .hidden {
            display: none !important;
        }
        
        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
        }
        
        .map-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        
        .map-item {
            background-color: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .map-title {
            font-size: 14px;
            text-align: center;
            margin-bottom: 8px;
            color: #4a5568;
        }
        
        .crosshair {
            cursor: crosshair;
        }
        
        .instructions {
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
            color: #4a5568;
        }
        
        .progress {
            width: 50%;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #3b82f6;
            width: 0%;
            transition: width 0.3s ease;
            animation: progress-animation 1.5s infinite ease-in-out;
        }
        
        .color-picker-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .color-picker-container {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            width: 100%;
        }
        
        .color-picker-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #4a5568;
        }
        
        .color-picker-input {
            width: 100%;
            height: 40px;
            margin-bottom: 15px;
            border: none;
            outline: none;
        }
        
        .color-picker-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        @keyframes progress-animation {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Christmas Lights Photo App</h1>
        
        <!-- Tab Navigation -->
        <div class="tab-container">
            <div id="cameraTab" class="tab active">Use Camera</div>
            <div id="fileTab" class="tab">Upload Image</div>
        </div>
        
        <!-- Camera View -->
        <div id="cameraView">
            <div class="input-container">
                <div id="cameraPlaceholder" class="input-placeholder">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path>
                        <circle cx="12" cy="13" r="3"></circle>
                    </svg>
                    <p>Camera inactive</p>
                </div>
                <video id="video" class="hidden" autoplay playsinline></video>
            </div>
            <div class="button-container">
                <button id="startCameraBtn" class="button button-green">Start Camera</button>
                <button id="takePictureBtn" class="button button-blue hidden">Take Photo</button>
            </div>
        </div>
        
        <!-- File Upload View -->
        <div id="fileView" class="hidden">
            <div class="input-container">
                <div id="fileUploadPlaceholder" class="input-placeholder">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    <p>Upload an image</p>
                </div>
                <img id="previewImage" class="hidden">
            </div>
            <div class="button-container">
                <input type="file" id="fileInput" class="file-input" accept="image/*">
                <label for="fileInput" class="file-label">Choose Image</label>
                <button id="useImageBtn" class="button button-blue hidden">Use This Image</button>
            </div>
        </div>
        
        <!-- Editor View -->
        <div id="editorView" class="hidden">
            <div class="editor-container">
                <!-- Sidebar with controls -->
                <div class="control-sidebar">
                    <!-- Density Slider -->
                    <div class="density-slider-container">
                        <input type="range" min="0.5" max="2" step="0.01" value="1" class="density-slider" id="densitySlider">
                        <div class="slider-tick max"><span class="slider-value">2.0</span></div>
                        <div class="slider-tick mid"><span class="slider-value">1.0</span></div>
                        <div class="slider-tick min"><span class="slider-value">0.5</span></div>
                        <div class="density-label">Density</div>
                    </div>
                    
                    <!-- Color Bar -->
                    <div class="color-bar-container" id="colorBar">
                        <!-- Color markers will be added dynamically -->
                    </div>
                </div>
                
                <!-- Main Canvas Container -->
                <div class="input-container">
                    <canvas id="canvas" class="crosshair"></canvas>
                    <div id="processingOverlay" class="processing-overlay hidden">
                        <p>Processing image...</p>
                        <div class="progress">
                            <div class="progress-bar"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="instructions" class="instructions">Click to add points for your Christmas lights</div>
            
            <div id="editorButtons" class="button-container">
                <button id="undoBtn" class="button button-purple" disabled>Undo</button>
                <button id="clearBtn" class="button button-red" disabled>Clear All</button>
                <button id="enhanceBtn" class="button button-green" disabled>Enhance Image</button>
                <button id="resetBtn" class="button button-gray">Start Over</button>
                <button id="downloadBtn" class="button button-blue hidden">Download Image</button>
            </div>
            
            <!-- Maps Container -->
            <div id="mapsContainer" class="map-container hidden">
                <div id="depthMapContainer" class="map-item">
                    <div class="map-title">Depth Map</div>
                    <img id="depthMapImage" width="100%">
                </div>
                <div id="lineMapContainer" class="map-item">
                    <div class="map-title">Line Map</div>
                    <img id="lineMapImage" width="100%">
                </div>
            </div>
            
            <!-- Results Container -->
            <div id="resultsContainer" class="hidden">
                <div class="input-container">
                    <img id="enhancedImage" width="100%">
                </div>
                <div class="instructions">AI Enhanced Image</div>
            </div>
        </div>
        
        <!-- Color Picker Overlay -->
        <div id="colorPickerOverlay" class="color-picker-overlay hidden">
            <div class="color-picker-container">
                <div class="color-picker-title">Choose Light Color</div>
                <input type="color" id="colorPickerInput" class="color-picker-input" value="#ff0000">
                <div class="color-picker-buttons">
                    <button id="cancelColorBtn" class="button button-gray">Cancel</button>
                    <button id="selectColorBtn" class="button button-blue">Select</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // App State
        const state = {
            mode: 'camera', // 'camera' or 'file'
            stream: null,
            splines: [], // Array of splines, each spline is array of points [{x,y}, {x,y}]
            activeSplineIndex: -1, // Index of current active spline
            fullResImage: null, // Original full resolution image
            lowResImage: null, // Resized image for processing
            depthMap: null,
            lineMap: null,
            animatingLights: true, // Always animating lights
            animationId: null,
            processing: false,
            enhancedImage: null,
            lastClickedPoint: null, // Used for tracking if we clicked on existing point
            inEnhanceMode: false, // Flag to control UI state after enhance button is pressed
            densityFactor: 1.0, // Default density factor for lights (new)
            colorMarkers: [], // Array of {y, color} objects for color timing (new)
            activeColorMarkerIndex: -1, // For color picker (new)
            colorPickerPosition: null // For positioning the color picker (new)
        };

        // DOM Elements
        const elements = {
            // Tabs
            cameraTab: document.getElementById('cameraTab'),
            fileTab: document.getElementById('fileTab'),
            
            // Views
            cameraView: document.getElementById('cameraView'),
            fileView: document.getElementById('fileView'),
            editorView: document.getElementById('editorView'),
            resultsContainer: document.getElementById('resultsContainer'),
            
            // Camera Elements
            video: document.getElementById('video'),
            cameraPlaceholder: document.getElementById('cameraPlaceholder'),
            startCameraBtn: document.getElementById('startCameraBtn'),
            takePictureBtn: document.getElementById('takePictureBtn'),
            
            // File Elements
            fileInput: document.getElementById('fileInput'),
            previewImage: document.getElementById('previewImage'),
            fileUploadPlaceholder: document.getElementById('fileUploadPlaceholder'),
            useImageBtn: document.getElementById('useImageBtn'),
            
            // Editor Elements
            canvas: document.getElementById('canvas'),
            processingOverlay: document.getElementById('processingOverlay'),
            instructions: document.getElementById('instructions'),
            
            // New Control Elements
            densitySlider: document.getElementById('densitySlider'),
            colorBar: document.getElementById('colorBar'),
            colorPickerOverlay: document.getElementById('colorPickerOverlay'),
            colorPickerInput: document.getElementById('colorPickerInput'),
            selectColorBtn: document.getElementById('selectColorBtn'),
            cancelColorBtn: document.getElementById('cancelColorBtn'),
            
            // Maps
            mapsContainer: document.getElementById('mapsContainer'),
            depthMapImage: document.getElementById('depthMapImage'),
            lineMapImage: document.getElementById('lineMapImage'),
            
            // Results
            enhancedImage: document.getElementById('enhancedImage'),
            
            // Buttons
            undoBtn: document.getElementById('undoBtn'),
            clearBtn: document.getElementById('clearBtn'),
            enhanceBtn: document.getElementById('enhanceBtn'),
            downloadBtn: document.getElementById('downloadBtn'),
            resetBtn: document.getElementById('resetBtn')
        };

        // Initialize canvas context
        const ctx = elements.canvas.getContext('2d');

        // Initialize with default colors
        function initializeDefaultColors() {
            // Add some default color markers
            addColorMarker(0, '#ff0000');     // Red at top
            addColorMarker(50, '#00ff00');    // Green at middle
            addColorMarker(100, '#0000ff');   // Blue at bottom
            addColorMarker(25, '#ffff00');    // Yellow at 25%
            addColorMarker(75, '#ff00ff');    // Magenta at 75%
        }

        // -----------------------
        // Density Slider Functions
        // -----------------------
        elements.densitySlider.addEventListener('input', function() {
            state.densityFactor = parseFloat(this.value);
            // If we have any ongoing light animations, update them
            if (state.animatingLights && state.splines.some(spline => spline.length >= 2)) {
                redrawCanvas();
            }
        });

        // -----------------------
        // Color Bar Functions
        // -----------------------
        elements.colorBar.addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const percentage = (y / rect.height) * 100;
            
            // Store position for color picker
            state.colorPickerPosition = percentage;
            
            // Show color picker
            elements.colorPickerOverlay.classList.remove('hidden');
        });

        // Color Picker Buttons
        elements.selectColorBtn.addEventListener('click', function() {
            // Add new color marker at the stored position
            if (state.colorPickerPosition !== null) {
                addColorMarker(state.colorPickerPosition, elements.colorPickerInput.value);
                state.colorPickerPosition = null;
                elements.colorPickerOverlay.classList.add('hidden');
                
                // If we have any ongoing light animations, update them
                if (state.animatingLights && state.splines.some(spline => spline.length >= 2)) {
                    redrawCanvas();
                }
            }
        });

        elements.cancelColorBtn.addEventListener('click', function() {
            state.colorPickerPosition = null;
            elements.colorPickerOverlay.classList.add('hidden');
        });

        // Add a color marker at the specified position
        function addColorMarker(percentage, color) {
            // Create marker element
            const marker = document.createElement('div');
            marker.className = 'color-marker';
            marker.style.top = `${percentage}%`;
            marker.style.backgroundColor = color;
            
            // Store in state
            state.colorMarkers.push({
                y: percentage,
                color: color,
                element: marker
            });
            
            // Sort markers by position (top to bottom)
            state.colorMarkers.sort((a, b) => a.y - b.y);
            
            // Add to DOM
            elements.colorBar.appendChild(marker);
            
            // Add click event to edit marker
            marker.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent triggering colorBar click
                
                // Check if we clicked on the delete button area (upper right corner)
                const rect = marker.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                // If we clicked in the upper right quadrant (where the Ã— appears on hover)
                if (clickX > rect.width/2 && clickY < rect.height/2) {
                    // Remove this marker
                    const index = state.colorMarkers.findIndex(m => m.element === marker);
                    if (index !== -1) {
                        state.colorMarkers.splice(index, 1);
                        elements.colorBar.removeChild(marker);
                        updateColorBarGradient();
                        
                        // If we have any ongoing light animations, update them
                        if (state.animatingLights && state.splines.some(spline => spline.length >= 2)) {
                            redrawCanvas();
                        }
                    }
                    return;
                }
                
                // Find index of this marker for editing
                const index = state.colorMarkers.findIndex(m => m.element === marker);
                if (index !== -1) {
                    // Set color picker to the current color
                    elements.colorPickerInput.value = state.colorMarkers[index].color;
                    
                    // Store index for reference
                    state.activeColorMarkerIndex = index;
                    
                    // Show color picker
                    elements.colorPickerOverlay.classList.remove('hidden');
                    
                    // Update existing marker instead of adding new one
                    elements.selectColorBtn.textContent = 'Update';
                    
                    // When updating, override the default behavior
                    elements.selectColorBtn.onclick = function() {
                        updateColorMarker(state.activeColorMarkerIndex, elements.colorPickerInput.value);
                        elements.colorPickerOverlay.classList.add('hidden');
                        
                        // Reset button text and behavior
                        elements.selectColorBtn.textContent = 'Select';
                        elements.selectColorBtn.onclick = null;
                        
                        // If we have any ongoing light animations, update them
                        if (state.animatingLights && state.splines.some(spline => spline.length >= 2)) {
                            redrawCanvas();
                        }
                    };
                }
            });
            
            // Update color bar gradient after adding a marker
            updateColorBarGradient();
        }

        // Update the color bar gradient based on current markers
        function updateColorBarGradient() {
            if (state.colorMarkers.length === 0) {
                elements.colorBar.style.background = '#f0f0f0'; // Neutral background
                return;
            }
            
            // If only one marker, solid color
            if (state.colorMarkers.length === 1) {
                elements.colorBar.style.background = state.colorMarkers[0].color;
                return;
            }
            
            // Build gradient based on markers
            let gradientStops = '';
            
            // Sort markers by position
            const sortedMarkers = [...state.colorMarkers].sort((a, b) => a.y - b.y);
            
            // Create gradient stops for each marker
            sortedMarkers.forEach((marker, i) => {
                gradientStops += `${marker.color} ${marker.y}%`;
                
                // Add comma separator except for the last item
                if (i < sortedMarkers.length - 1) {
                    gradientStops += ', ';
                }
            });
            
            // Apply the gradient
            elements.colorBar.style.background = `linear-gradient(to bottom, ${gradientStops})`;
        }

        // Update an existing color marker
        function updateColorMarker(index, color) {
            if (index >= 0 && index < state.colorMarkers.length) {
                state.colorMarkers[index].color = color;
                state.colorMarkers[index].element.style.backgroundColor = color;
                state.activeColorMarkerIndex = -1;
                
                // Update color bar gradient after changing a marker
                updateColorBarGradient();
            }
        }

        // Get color based on position in the animation sequence
        function getColorFromMarkers(position) {
            // Position is 0-1 value representing where in the animation sequence we are
            
            // If no markers, use default colors
            if (state.colorMarkers.length === 0) {
                const defaultColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
                return defaultColors[Math.floor(position * defaultColors.length) % defaultColors.length];
            }
            
            // If only one marker, use that color
            if (state.colorMarkers.length === 1) {
                return state.colorMarkers[0].color;
            }
            
            // Position is 0-1, but markers are stored as percentages (0-100)
            const targetPosition = position * 100;
            
            // Find markers that bound this position
            let lowerMarker = state.colorMarkers[0];
            let upperMarker = state.colorMarkers[state.colorMarkers.length - 1];
            
            for (let i = 0; i < state.colorMarkers.length - 1; i++) {
                if (state.colorMarkers[i].y <= targetPosition && state.colorMarkers[i + 1].y >= targetPosition) {
                    lowerMarker = state.colorMarkers[i];
                    upperMarker = state.colorMarkers[i + 1];
                    break;
                }
            }
            
            // If position is outside the range of markers, use the closest marker
            if (targetPosition <= lowerMarker.y) return lowerMarker.color;
            if (targetPosition >= upperMarker.y) return upperMarker.color;
            
            // Calculate interpolation factor between markers
            const range = upperMarker.y - lowerMarker.y;
            const factor = (targetPosition - lowerMarker.y) / range;
            
            // Interpolate colors (simple RGB interpolation)
            return interpolateColors(lowerMarker.color, upperMarker.color, factor);
        }

        // Helper function to interpolate between two colors
        function interpolateColors(color1, color2, factor) {
            // Convert hex to RGB
            const r1 = parseInt(color1.substring(1, 3), 16);
            const g1 = parseInt(color1.substring(3, 5), 16);
            const b1 = parseInt(color1.substring(5, 7), 16);
            
            const r2 = parseInt(color2.substring(1, 3), 16);
            const g2 = parseInt(color2.substring(3, 5), 16);
            const b2 = parseInt(color2.substring(5, 7), 16);
            
            // Interpolate
            const r = Math.round(r1 + factor * (r2 - r1));
            const g = Math.round(g1 + factor * (g2 - g1));
            const b = Math.round(b1 + factor * (b2 - b1));
            
            // Convert back to hex
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // -----------------------
        // Tab Navigation
        // -----------------------
        elements.cameraTab.addEventListener('click', () => {
            if (state.mode === 'camera') return;
            resetApp();
            state.mode = 'camera';
            elements.cameraTab.classList.add('active');
            elements.fileTab.classList.remove('active');
            elements.cameraView.classList.remove('hidden');
            elements.fileView.classList.add('hidden');
        });

        elements.fileTab.addEventListener('click', () => {
            if (state.mode === 'file') return;
            resetApp();
            // Stop camera if active
            stopCamera();
            
            state.mode = 'file';
            elements.fileTab.classList.add('active');
            elements.cameraTab.classList.remove('active');
            elements.fileView.classList.remove('hidden');
            elements.cameraView.classList.add('hidden');
        });

        // -----------------------
        // Camera Functions
        // -----------------------
        elements.startCameraBtn.addEventListener('click', startCamera);
        
        async function startCamera() {
            try {
                state.stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                elements.video.srcObject = state.stream;
                elements.video.classList.remove('hidden');
                elements.cameraPlaceholder.classList.add('hidden');
                elements.takePictureBtn.classList.remove('hidden');
                elements.startCameraBtn.classList.add('hidden');
                
                // Play video
                await elements.video.play();
                
            } catch (err) {
                console.error('Camera error:', err);
                alert('Could not access camera: ' + err.message);
            }
        }

        function stopCamera() {
            if (state.stream) {
                state.stream.getTracks().forEach(track => track.stop());
                state.stream = null;
            }
            
            elements.video.srcObject = null;
            elements.video.classList.add('hidden');
            elements.cameraPlaceholder.classList.remove('hidden');
            elements.takePictureBtn.classList.add('hidden');
            elements.startCameraBtn.classList.remove('hidden');
        }

        elements.takePictureBtn.addEventListener('click', captureImage);
        
        function captureImage() {
            // Create a temporary canvas to capture the video frame
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = elements.video.videoWidth;
            tempCanvas.height = elements.video.videoHeight;
            
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(elements.video, 0, 0, tempCanvas.width, tempCanvas.height);
            
            // Get the full resolution image data
            state.fullResImage = tempCanvas.toDataURL('image/jpeg', 0.9);
            
            // Stop the camera
            stopCamera();
            
            // Process the captured image
            processImage(state.fullResImage);
        }

        // -----------------------
        // File Upload Functions
        // -----------------------
        elements.fileInput.addEventListener('change', handleFileSelect);
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file || !file.type.match('image.*')) {
                alert('Please select a valid image file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (event) => {
                elements.previewImage.src = event.target.result;
                elements.previewImage.classList.remove('hidden');
                elements.fileUploadPlaceholder.classList.add('hidden');
                elements.useImageBtn.classList.remove('hidden');
            };
            
            reader.readAsDataURL(file);
        }

        elements.useImageBtn.addEventListener('click', useUploadedImage);
        
        function useUploadedImage() {
            state.fullResImage = elements.previewImage.src;
            processImage(state.fullResImage);
        }

        // -----------------------
        // Image Processing
        // -----------------------
        function processImage(imageUrl) {
            // Show editor view and hide input views
            elements.cameraView.classList.add('hidden');
            elements.fileView.classList.add('hidden');
            elements.editorView.classList.remove('hidden');
            elements.resultsContainer.classList.add('hidden');
            
            // Show processing overlay
            elements.processingOverlay.classList.remove('hidden');
            state.processing = true;
            
            // Initialize the default color markers
            initializeDefaultColors();
            
            // Load and resize image for the canvas
            const img = new Image();
            img.onload = () => {
                // Create a lower resolution version for processing
                state.lowResImage = createLowResVersion(img);
                
                // Generate maps (in a real app, these would come from a server)
                setTimeout(() => {
                    state.depthMap = createMockDepthMap();
                    state.lineMap = createMockLineMap();
                    
                    elements.depthMapImage.src = state.depthMap;
                    elements.lineMapImage.src = state.lineMap;
                    elements.mapsContainer.classList.remove('hidden');
                    
                    // Initialize canvas with the FULL RES image
                    initializeCanvas(state.fullResImage);
                    
                    // Hide processing overlay
                    elements.processingOverlay.classList.add('hidden');
                    state.processing = false;
                    
                    // Start in drawing mode automatically
                    startLightsAnimation();
                }, 1500);
            };
            
            img.src = imageUrl;
        }

        function createLowResVersion(img) {
            // Create a lower resolution version for better performance
            const canvas = document.createElement('canvas');
            
            // Target resolution (max 640x480)
            const maxWidth = 640;
            const maxHeight = 480;
            
            let width = img.width;
            let height = img.height;
            
            // Scale down if needed while preserving aspect ratio
            if (width > height) {
                if (width > maxWidth) {
                    height = Math.round(height * maxWidth / width);
                    width = maxWidth;
                }
            } else {
                if (height > maxHeight) {
                    width = Math.round(width * maxHeight / height);
                    height = maxHeight;
                }
            }
            
            canvas.width = width;
            canvas.height = height;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            return canvas.toDataURL('image/jpeg', 0.8);
        }

        function initializeCanvas(imageUrl) {
            const img = new Image();
            img.onload = () => {
                // Size canvas to match full-res image but limit to viewport
                const maxWidth = Math.min(window.innerWidth - 40, img.width);
                const aspectRatio = img.height / img.width;
                
                elements.canvas.width = maxWidth;
                elements.canvas.height = maxWidth * aspectRatio;
                
                // Draw image to canvas
                ctx.drawImage(img, 0, 0, elements.canvas.width, elements.canvas.height);
            };
            
            img.src = imageUrl;
        }

        // -----------------------
        // Mock Map Generation
        // -----------------------
        function createMockDepthMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 480;
            const ctx = canvas.getContext('2d');
            
            // Create a gradient from top (far) to bottom (near)
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'black');     // Far
            gradient.addColorStop(1, 'white');     // Near
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            return canvas.toDataURL();
        }

        function createMockLineMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 480;
            const ctx = canvas.getContext('2d');
            
            // Black background
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // White lines
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            
            // Horizontal lines
            for (let y = 60; y < canvas.height; y += 80) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Vertical lines
            for (let x = 80; x < canvas.width; x += 120) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Diagonal lines
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(canvas.width, 0);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();
            
            return canvas.toDataURL();
        }

        // -----------------------
        // Drawing Functions
        // -----------------------
        elements.canvas.addEventListener('click', handleCanvasClick);
        
        function handleCanvasClick(e) {
            // If in enhance mode, don't allow further drawing
            if (state.inEnhanceMode) return;
            
            const rect = elements.canvas.getBoundingClientRect();
            const scaleX = elements.canvas.width / rect.width;
            const scaleY = elements.canvas.height / rect.height;
            
            // Calculate click position on canvas
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // Snap to line if nearby
            const snappedPoint = snapToLine(x, y);
            
            // Check if clicked on an existing point
            const existingPoint = findExistingPoint(snappedPoint.x, snappedPoint.y);
            
            if (existingPoint) {
                // Clicked on existing point
                const { splineIndex, pointIndex, isEndpoint } = existingPoint;
                
                if (state.lastClickedPoint) {
                    // Second click after selecting a point - ignore if clicking same point again
                    if (state.lastClickedPoint.splineIndex === splineIndex && 
                        state.lastClickedPoint.pointIndex === pointIndex) {
                        return;
                    }
                    
                    // Reset last clicked point
                    state.lastClickedPoint = null;
                } else {
                    // First click on an existing point
                    if (isEndpoint) {
                        // Clicked on endpoint, prepare to extend this spline
                        state.activeSplineIndex = splineIndex;
                        state.lastClickedPoint = { splineIndex, pointIndex, isEndpoint };
                    } else {
                        // Clicked on middle point, start new spline from here
                        state.splines.push([{ 
                            x: state.splines[splineIndex][pointIndex].x, 
                            y: state.splines[splineIndex][pointIndex].y 
                        }]);
                        state.activeSplineIndex = state.splines.length - 1;
                        state.lastClickedPoint = null;
                    }
                    redrawCanvas();
                    return;
                }
            }
            
            // Normal click (not on existing point)
            if (state.lastClickedPoint) {
                // Second click after selecting an endpoint
                const { splineIndex, pointIndex, isEndpoint } = state.lastClickedPoint;
                
                // Add to beginning or end of spline
                if (pointIndex === 0) {
                    // Add to beginning
                    state.splines[splineIndex].unshift(snappedPoint);
                } else {
                    // Add to end
                    state.splines[splineIndex].push(snappedPoint);
                }
                
                state.lastClickedPoint = null;
            } else if (state.activeSplineIndex >= 0 && state.splines[state.activeSplineIndex].length === 1) {
                // Adding second point to active spline
                state.splines[state.activeSplineIndex].push(snappedPoint);
            } else {
                // Starting a new spline
                state.splines.push([snappedPoint]);
                state.activeSplineIndex = state.splines.length - 1;
            }
            
            // Redraw and update buttons
            redrawCanvas();
            updateButtonStates();
        }

        function findExistingPoint(x, y) {
            const threshold = 10; // Distance threshold for clicking on a point
            
            for (let splineIndex = 0; splineIndex < state.splines.length; splineIndex++) {
                const spline = state.splines[splineIndex];
                
                for (let pointIndex = 0; pointIndex < spline.length; pointIndex++) {
                    const point = spline[pointIndex];
                    const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                    
                    if (distance <= threshold) {
                        // Determine if it's an endpoint
                        const isEndpoint = pointIndex === 0 || pointIndex === spline.length - 1;
                        return { splineIndex, pointIndex, isEndpoint };
                    }
                }
            }
            
            return null;
        }

        function snapToLine(x, y) {
            // Scale coordinates to match line map dimensions
            const scaleX = 640 / elements.canvas.width;
            const scaleY = 480 / elements.canvas.height;
            
            const mapX = x * scaleX;
            const mapY = y * scaleY;
            
            // Snap threshold
            const threshold = 15;
            
            // Check horizontal lines
            for (let lineY = 60; lineY < 480; lineY += 80) {
                if (Math.abs(mapY - lineY) < threshold) {
                    return { x, y: lineY / scaleY };
                }
            }
            
            // Check vertical lines
            for (let lineX = 80; lineX < 640; lineX += 120) {
                if (Math.abs(mapX - lineX) < threshold) {
                    return { x: lineX / scaleX, y };
                }
            }
            
            // Check diagonal from top-left to bottom-right
            const diag1Dist = Math.abs(mapX - mapY);
            if (diag1Dist < threshold) {
                const avg = (mapX + mapY) / 2;
                return { x: avg / scaleX, y: avg / scaleY };
            }
            
            // Check diagonal from top-right to bottom-left
            const diag2Dist = Math.abs((640 - mapX) - mapY);
            if (diag2Dist < threshold) {
                const avgY = (mapY + (640 - mapX)) / 2;
                return { x: (640 - avgY) / scaleX, y: avgY / scaleY };
            }
            
            // If no line is nearby, return the original point
            return { x, y };
        }

        function redrawCanvas() {
            // Always re-render with lights if we have splines
            if (state.splines.some(spline => spline.length >= 2)) {
                // Just trigger a re-render of the animation loop,
                // which will handle showing the lights
                // The animation is always running when in editor mode
            } else {
                // Draw the original image without lights (no valid splines yet)
                const img = new Image();
                img.onload = () => {
                    // Clear canvas and draw the image
                    ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
                    ctx.drawImage(img, 0, 0, elements.canvas.width, elements.canvas.height);
                    
                    // Draw all splines as straight lines
                    for (const spline of state.splines) {
                        if (spline.length < 2) {
                            // For single points, just draw the point
                            ctx.beginPath();
                            ctx.arc(spline[0].x, spline[0].y, 5, 0, Math.PI * 2);
                            ctx.fillStyle = 'red';
                            ctx.fill();
                        } else {
                            // Draw straight lines between points
                            ctx.beginPath();
                            ctx.moveTo(spline[0].x, spline[0].y);
                            
                            for (let i = 1; i < spline.length; i++) {
                                ctx.lineTo(spline[i].x, spline[i].y);
                            }
                            
                            ctx.strokeStyle = 'yellow';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            
                            // Draw points
                            for (const point of spline) {
                                ctx.beginPath();
                                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                                ctx.fillStyle = 'red';
                                ctx.fill();
                            }
                        }
                    }
                    
                    // Highlight the last clicked point if any
                    if (state.lastClickedPoint) {
                        const { splineIndex, pointIndex } = state.lastClickedPoint;
                        const point = state.splines[splineIndex][pointIndex];
                        
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 7, 0, Math.PI * 2);
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                };
                
                img.src = state.fullResImage;
            }
        }

        function updateButtonStates() {
            // Count total points in all splines
            const totalPoints = state.splines.reduce((sum, spline) => sum + spline.length, 0);
            
            // Clear button enabled if we have any points
            elements.clearBtn.disabled = totalPoints === 0;
            
            // Undo button enabled if we have any points
            elements.undoBtn.disabled = totalPoints === 0;
            
            // Enhance button enabled if we have at least one spline with 2+ points
            const hasCompleteSpline = state.splines.some(spline => spline.length >= 2);
            elements.enhanceBtn.disabled = !hasCompleteSpline;
        }

        // -----------------------
        // Undo Function
        // -----------------------
        elements.undoBtn.addEventListener('click', undoLastAction);
        
        function undoLastAction() {
            if (state.splines.length === 0) return;
            
            // If we have a last clicked point, clear it
            if (state.lastClickedPoint) {
                state.lastClickedPoint = null;
                redrawCanvas();
                return;
            }
            
            // If we have an active spline with only one point, remove it entirely
            if (state.activeSplineIndex >= 0 && 
                state.splines[state.activeSplineIndex].length === 1) {
                state.splines.splice(state.activeSplineIndex, 1);
                state.activeSplineIndex = state.splines.length - 1;
            } 
            // If we have an active spline with multiple points, remove the last point
            else if (state.activeSplineIndex >= 0 && 
                    state.splines[state.activeSplineIndex].length > 1) {
                state.splines[state.activeSplineIndex].pop();
                
                // If we've removed all but one point, keep the active index
                if (state.splines[state.activeSplineIndex].length === 0) {
                    state.splines.splice(state.activeSplineIndex, 1);
                    state.activeSplineIndex = state.splines.length - 1;
                }
            } 
            // Otherwise remove the last point from the last spline
            else if (state.splines.length > 0) {
                const lastSplineIndex = state.splines.length - 1;
                
                if (state.splines[lastSplineIndex].length > 1) {
                    state.splines[lastSplineIndex].pop();
                } else {
                    state.splines.pop();
                    state.activeSplineIndex = state.splines.length - 1;
                }
            }
            
            redrawCanvas();
            updateButtonStates();
        }

        // -----------------------
        // Clear Function
        // -----------------------
        elements.clearBtn.addEventListener('click', clearPoints);
        
        function clearPoints() {
            state.splines = [];
            state.activeSplineIndex = -1;
            state.lastClickedPoint = null;
            redrawCanvas();
            updateButtonStates();
        }

        // -----------------------
        // Christmas Lights
        // -----------------------
        function startLightsAnimation() {
            state.animatingLights = true;
            
            // Load original image
            const img = new Image();
            img.onload = () => {
                let phase = 0;
                
                // Animation function
                const animate = () => {
                    if (!state.animatingLights) return;
                    
                    // Draw background image
                    ctx.drawImage(img, 0, 0, elements.canvas.width, elements.canvas.height);
                    
                    // Only draw splines if we're not in enhance mode
                    // This is for the editing view only, not for the final image
                    if (!state.inEnhanceMode) {
                        // Draw all splines with points for editing
                        for (const spline of state.splines) {
                            // Draw straight lines between points
                            if (spline.length >= 2) {
                                ctx.beginPath();
                                ctx.moveTo(spline[0].x, spline[0].y);
                                
                                for (let i = 1; i < spline.length; i++) {
                                    ctx.lineTo(spline[i].x, spline[i].y);
                                }
                                
                                ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                    }
                    
                    // Draw lights for each spline
                    for (const spline of state.splines) {
                        if (spline.length < 2) {
                            // For splines with only one point, just draw the point if not in enhance mode
                            if (spline.length === 1 && !state.inEnhanceMode) {
                                ctx.beginPath();
                                ctx.arc(spline[0].x, spline[0].y, 5, 0, Math.PI * 2);
                                ctx.fillStyle = 'red';
                                ctx.fill();
                            }
                            continue;
                        }
                        
                        // Calculate evenly spaced points along the spline, adjusted for depth
                        const lightPoints = calculateDepthAdjustedLightPoints(spline);
                        
                        // Draw each light
                        lightPoints.forEach((point, i) => {
                            // Color based on position in the animation sequence
                            const colorPosition = (i / lightPoints.length + phase) % 1;
                            const color = getColorFromMarkers(colorPosition);
                            
                            // Draw light with depth-based size
                            const depth = getDepthAtPoint(point.x, point.y);
                            const size = 3 + (depth * 7); // Size between 3-10px
                            
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                            ctx.fillStyle = color;
                            ctx.fill();
                            
                            // Add glow effect
                            const gradient = ctx.createRadialGradient(
                                point.x, point.y, 0,
                                point.x, point.y, size * 2
                            );
                            gradient.addColorStop(0, color);
                            gradient.addColorStop(1, 'rgba(0,0,0,0)');
                            
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, size * 2, 0, Math.PI * 2);
                            ctx.fillStyle = gradient;
                            ctx.fill();
                        });
                    }
                    
                    // Draw control points on top of lights only if not in enhance mode
                    if (!state.inEnhanceMode) {
                        for (const spline of state.splines) {
                            // Draw points
                            for (const point of spline) {
                                ctx.beginPath();
                                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                                ctx.fillStyle = 'red';
                                ctx.fill();
                                ctx.strokeStyle = 'white';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                        
                        // Highlight the last clicked point if any
                        if (state.lastClickedPoint) {
                            const { splineIndex, pointIndex } = state.lastClickedPoint;
                            const point = state.splines[splineIndex][pointIndex];
                            
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, 7, 0, Math.PI * 2);
                            ctx.strokeStyle = '#00ffff';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                    
                    // Increment phase for animation
                    phase += 0.05;
                    
                    // Continue animation
                    state.animationId = requestAnimationFrame(animate);
                };
                
                // Start animation loop
                animate();
            };
            
            img.src = state.fullResImage;
        }

        function stopLightsAnimation() {
            state.animatingLights = false;
            
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
        }

        function calculateDepthAdjustedLightPoints(spline) {
            // Calculate points along a spline for lights using a depth accumulation method
            if (spline.length < 1) return [];
            
            const points = [];
            // Apply density factor to threshold
            // For 0.5 (sparse): THRESHOLD is doubled
            // For 1 (normal): THRESHOLD is unchanged
            // For 2 (dense): THRESHOLD is halved
            const baseThreshold = 10; // Base threshold for placing a light
            const THRESHOLD = baseThreshold / state.densityFactor;
            const STEP_SIZE = 1; // Step size in pixels for traversing the spline
            
            // Process each segment of the spline
            for (let i = 0; i < spline.length - 1; i++) {
                const start = spline[i];
                const end = spline[i + 1];
                
                // Calculate segment properties
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
                
                // Skip very short segments
                if (segmentLength < 5) continue;
                
                // Calculate number of steps for this segment
                const steps = Math.ceil(segmentLength / STEP_SIZE);
                
                // Initialize depth accumulator
                let depthAccumulator = 0;
                
                // Track where the last light was placed to avoid double lights at junctions
                let lastLightPosition = -1;
                
                // Traverse the segment step by step
                for (let step = 0; step <= steps; step++) {
                    const t = step / steps;
                    
                    // Calculate current position along the segment
                    const x = start.x + dx * t;
                    const y = start.y + dy * t;
                    
                    // Sample depth at current position
                    const depth = getDepthAtPoint(x, y);
                    
                    // Accumulate depth
                    // Use depth factor to make deeper areas (higher depth values) accumulate faster
                    const depthFactor = 0.5 + (depth * 1.5); // Ranges from 0.5-2.0
                    depthAccumulator += depthFactor * (STEP_SIZE / 10);
                    
                    // Check if we should place a light
                    if (depthAccumulator >= THRESHOLD) {
                        // Skip if we're at a junction point and this isn't the first segment
                        if (i > 0 && step === 0) {
                            // Reset accumulator but don't place light at junction
                            // IMPROVED: Subtract threshold instead of resetting to zero
                            depthAccumulator -= THRESHOLD;
                            continue;
                        }
                        
                        // Skip if we're too close to the last light
                        if (lastLightPosition !== -1 && (step - lastLightPosition) < 3) {
                            continue;
                        }
                        
                        // Place a light at this position
                        points.push({ x, y });
                        
                        // IMPROVED: Subtract threshold instead of resetting to zero
                        depthAccumulator -= THRESHOLD;
                        lastLightPosition = step;
                    }
                }
            }
            
            return points;
        }

        function getDepthAtPoint(x, y) {
            // Convert canvas coordinates to depth map coordinates
            const depthX = Math.floor((x / elements.canvas.width) * 640);
            const depthY = Math.floor((y / elements.canvas.height) * 480);
            
            // In a real implementation, this would sample the actual depth map
            // For this demo, we create a more dynamic depth map with various patterns
            
            // Base depth from Y position (higher = further)
            let depth = depthY / 480;
            
            // Add horizontal bands of varying depth
            const bandDepth = 0.2 * Math.sin(depthY / 30);
            
            // Add some vertical variation
            const verticalVariation = 0.1 * Math.sin(depthX / 40);
            
            // Add diagonal variation
            const diagonalVariation = 0.15 * Math.sin((depthX + depthY) / 50);
            
            // Combine all variations
            depth = depth + bandDepth + verticalVariation + diagonalVariation;
            
            // Normalize to 0-1 range
            depth = Math.max(0, Math.min(1, depth));
            
            return depth;
        }

        // -----------------------
        // Enhance Image
        // -----------------------
        elements.enhanceBtn.addEventListener('click', enhanceImage);
        
        function enhanceImage() {
            // Set enhance mode to disable further drawing
            state.inEnhanceMode = true;
            
            // Show processing overlay
            elements.processingOverlay.classList.remove('hidden');
            state.processing = true;
            
            // Adjust UI for enhance mode
            elements.undoBtn.classList.add('hidden');
            elements.clearBtn.classList.add('hidden');
            elements.enhanceBtn.classList.add('hidden');
            elements.downloadBtn.classList.remove('hidden');
            
            // Remove crosshair cursor
            elements.canvas.classList.remove('crosshair');
            
            // Show processing for a short time
            setTimeout(() => {
                // Capture a frame with just the image and lights, no splines or control points
                // We do this by temporarily rendering a frame with inEnhanceMode true,
                // which will exclude the splines and control points
                applyEnhancements();
            }, 2000);
        }

        function applyEnhancements() {
            // Get current canvas image (this has the lights on it)
            const canvasWithLights = elements.canvas.toDataURL('image/jpeg', 0.9);
            
            const img = new Image();
            img.onload = () => {
                // Create a new canvas for the enhanced image
                const enhanceCanvas = document.createElement('canvas');
                enhanceCanvas.width = img.width;
                enhanceCanvas.height = img.height;
                
                const enhanceCtx = enhanceCanvas.getContext('2d');
                
                // Draw original image
                enhanceCtx.drawImage(img, 0, 0);
                
                // Apply effects to simulate AI enhancement
                enhanceCtx.filter = 'contrast(110%) brightness(110%) saturate(120%)';
                enhanceCtx.globalCompositeOperation = 'source-atop';
                enhanceCtx.drawImage(img, 0, 0);
                
                // Reset filters
                enhanceCtx.filter = 'none';
                enhanceCtx.globalCompositeOperation = 'source-over';
                
                // Add subtle vignette
                const gradient = enhanceCtx.createRadialGradient(
                    enhanceCanvas.width / 2, enhanceCanvas.height / 2, enhanceCanvas.height * 0.3,
                    enhanceCanvas.width / 2, enhanceCanvas.height / 2, enhanceCanvas.height * 0.8
                );
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, 'rgba(0,0,0,0.3)');
                
                enhanceCtx.fillStyle = gradient;
                enhanceCtx.fillRect(0, 0, enhanceCanvas.width, enhanceCanvas.height);
                
                // Save the enhanced image
                state.enhancedImage = enhanceCanvas.toDataURL('image/jpeg', 0.9);
                
                // Display enhanced image directly in the main canvas
                const displayImg = new Image();
                displayImg.onload = () => {
                    // Clear the canvas entirely
                    ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
                    
                    // Draw the enhanced image on the main canvas
                    ctx.drawImage(displayImg, 0, 0, elements.canvas.width, elements.canvas.height);
                    
                    // Hide maps
                    elements.mapsContainer.classList.add('hidden');
                    
                    // Update instructions
                    elements.instructions.textContent = 'Your enhanced image is ready!';
                    
                    // Hide processing overlay
                    elements.processingOverlay.classList.add('hidden');
                    state.processing = false;
                    
                    // Stop animation loop since we're replacing it
                    stopLightsAnimation();
                };
                displayImg.src = state.enhancedImage;
            };
            
            img.src = canvasWithLights;
        }

        // -----------------------
        // Download Image
        // -----------------------
        elements.downloadBtn.addEventListener('click', downloadImage);
        
        function downloadImage() {
            if (state.inEnhanceMode && state.enhancedImage) {
                // Download enhanced image
                const link = document.createElement('a');
                link.href = state.enhancedImage;
                link.download = 'christmas-lights-photo.jpg';
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                // Download current canvas image with lights
                const link = document.createElement('a');
                link.href = elements.canvas.toDataURL('image/jpeg', 0.9);
                link.download = 'christmas-lights-photo.jpg';
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // -----------------------
        // Reset
        // -----------------------
        elements.resetBtn.addEventListener('click', resetApp);
        
        function resetApp() {
            // Stop animations if running
            stopLightsAnimation();
            
            // Reset state
            state.splines = [];
            state.activeSplineIndex = -1;
            state.lastClickedPoint = null;
            state.fullResImage = null;
            state.lowResImage = null;
            state.depthMap = null;
            state.lineMap = null;
            state.enhancedImage = null;
            state.inEnhanceMode = false;
            state.densityFactor = 1.0;
            
            // Reset density slider
            elements.densitySlider.value = 1.0;
            
            // Clear color markers
            while (elements.colorBar.firstChild) {
                elements.colorBar.removeChild(elements.colorBar.firstChild);
            }
            state.colorMarkers = [];
            
            // Reset UI based on current mode
            if (state.mode === 'camera') {
                elements.cameraView.classList.remove('hidden');
                elements.fileView.classList.add('hidden');
                elements.editorView.classList.add('hidden');
                
                elements.video.classList.add('hidden');
                elements.cameraPlaceholder.classList.remove('hidden');
                elements.takePictureBtn.classList.add('hidden');
                elements.startCameraBtn.classList.remove('hidden');
            } else {
                elements.fileView.classList.remove('hidden');
                elements.cameraView.classList.add('hidden');
                elements.editorView.classList.add('hidden');
                
                elements.previewImage.classList.add('hidden');
                elements.fileUploadPlaceholder.classList.remove('hidden');
                elements.useImageBtn.classList.add('hidden');
                elements.fileInput.value = ''; // Reset file input
            }
            
            // Reset editor UI
            elements.undoBtn.classList.remove('hidden');
            elements.clearBtn.classList.remove('hidden');
            elements.enhanceBtn.classList.remove('hidden');
            elements.downloadBtn.classList.add('hidden');
            elements.canvas.classList.add('crosshair');
            elements.instructions.textContent = 'Click to add points for your Christmas lights';
            elements.mapsContainer.classList.add('hidden');
            elements.resultsContainer.classList.add('hidden');
            
            // Reset button states
            elements.undoBtn.disabled = true;
            elements.clearBtn.disabled = true;
            elements.enhanceBtn.disabled = true;
        }
        
        // Initialize the app by setting up the color picker cancel button
        elements.cancelColorBtn.addEventListener('click', function() {
            elements.colorPickerOverlay.classList.add('hidden');
            state.colorPickerPosition = null;
            state.activeColorMarkerIndex = -1;
            
            // Reset select button behavior
            elements.selectColorBtn.textContent = 'Select';
            elements.selectColorBtn.onclick = null;
        });
    </script>
</body>
</html>